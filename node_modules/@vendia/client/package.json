{
  "name": "@vendia/client",
  "version": "0.3.3",
  "author": "Vendia Inc",
  "license": "MIT",
  "contributors": [
    "Brett Andrews <brett@vendia.net> (https://www.halfstack.software/)",
    "David Wells <david@vendia.net> (https://davidwells.io/)",
    "Jake Partusch <jake@vendia.net>",
    "Matt Silverstein <matt@vendia.net> (https://mattsilverstein.com/)"
  ],
  "description": "An isomorphic, type-safe JavaScript/TypeScript client for interacting with your Vendia Universal Apps (Unis). Automatically generates custom code to match your Uni's schema.",
  "keywords": [
    "javascript",
    "typescript",
    "vendia",
    "uni",
    "share",
    "universal",
    "isomorphic",
    "client"
  ],
  "main": "index.js",
  "module": "index.module.js",
  "types": "index.d.ts",
  "bin": "bin/vendia-client.js",
  "files": [
    "src",
    "bin",
    "scripts/postinstall.js",
    "index.js",
    "index.d.ts",
    "index.module.js",
    "tsconfig.json",
    "tsconfig.module.json"
  ],
  "devDependencies": {
    "@types/debug": "^4.1.7",
    "@types/node": "^16.11.26",
    "rimraf": "^3.0.2",
    "ts-node": "^10.7.0",
    "typescript": "^4.6.2"
  },
  "@comment": "Putting full graphql package in dependencies due to issue in readme.md",
  "dependencies": {
    "@lukeed/uuid": "^2.0.0",
    "@vendia/codegen-tools": "0.0.20",
    "chalk": "^4.1.2",
    "debug": "^4.3.4",
    "graphql": "15.8.0",
    "graphql-request": "^4.2.0",
    "graphql-tag": "^2.12.6",
    "graphql-ws": "^5.8.2",
    "isomorphic-ws": "^4.0.1",
    "ws": "^8.5.0"
  },
  "scripts": {
    "_prepackage": "node scripts/clean-test-app-install.js",
    "_postpackage": "node scripts/postpackage.js",
    "_package": "pnpm _prepackage && pnpm pack && pnpm _postpackage",
    "_link-packages": "cd test/vendia-client-test-app && pnpm link ../../../codegen-tools && pnpm link ../../../vendia-client-plugin-file-upload",
    "_npm-install-test-dir": "cd test/vendia-client-test-app && VENDIA_CLIENT_CLI_ENV=dev npm install",
    "_run-tests": "cd test/vendia-client-test-app && pnpm test",
    "test:no-link": "pnpm _package && pnpm _npm-install-test-dir && pnpm _run-tests",
    "test": "pnpm _package && pnpm _link-packages && pnpm _npm-install-test-dir && pnpm _run-tests",
    "postinstall": "node scripts/postinstall.js",
    "lint": "eslint . --ext ts --ignore-path .gitignore"
  },
  "readme": "\n> Thank you for checking out the Vendia Client SDK! We've been building and testing this client internally for months and enthusiastically encourage you to try it out! The project is still under active development, however, and **the API is subject to change**. We expect the API to settle with public 1.0.0 release by mid 2022. Thanks for your patience!\n\n# @vendia/client - a type-safe client for Vendia\n\nThe Client SDK is a type-safe **TypeScript & JavaScript** client for your Uni's API with **auto-generated code customized to match your Uni's schema!**\n\nIf you're new to Vendia and wondering what a \"Uni\" is? This is a great place to start: [What is a Uni?](https://www.vendia.net/docs/share/dev-and-use-unis).\n\nThe official Vendia client is the easiest way to start working with your Uni. Enjoy autocomplete (intellisense) in your favorite IDE, built-in support for both HTTP and websocket GraphQL APIs (see [Realtime Data](#realtime-data-graphql-subscriptions)), multiple authentication methods, file upload/download, and additional conveniences. The client is _[isomorphic](https://en.wikipedia.org/wiki/Isomorphic_JavaScript)_ — it can be used in both the **browser** and **server (node.js)**.\n\n**What does \"auto-generated code\" mean?**\n\nCode based on your Uni's schema will be generated automatically during installation (you can read more about how it works [in the appendix below](#code-generation-details)). If your schema included a \"product\" entity, for example, your generated client would include the following methods:\n\n```tsx\n// List all the products\nconst listProductsResponse = await client.entities.product.list();\n\n// Add a new product\nconst addProductResponse = await client.entities.product.add({\n  name: 'super-widget',\n  inventory: 100,\n});\n\n// Get a product by ID\nconst getProductResponse = await client.entities.product.get('abc-123');\n```\n\n# Getting started\n\n## Prerequisites\n\n- Create a [Vendia account](https://share.vendia.net/) and deploy a Uni you'd like to use!\n- Install the [Vendia CLI](https://www.vendia.net/docs/share/cli/guide) (or update via `npm update -g @vendia/share-cli`)\n\n```bash\nnpm install -g @vendia/share-cli\n```\n\n## Step 1: Pulling your Uni’s schema\n\nWe’ll need to store some information about your Uni and its schema locally in order to generate custom, type-safe client code — we’ll use the Vendia CLI to authenticate into your Uni, fetch the required data, and store it locally.\n\n_Note: if you've already got a `.vendia` directory (eg, another team member has already committed the `.vendia` directory and schema files to your repo), you can skip this step and continue to [installation](#step-2-installing-the-client)_\n\n1. Navigate to the _root directory_ of an existing project you’ve been working on or create a new, empty directory and `cd` into it.\n2. Use the following command and follow the prompts to fetch your Uni's schema data and store it locally:\n\n```bash\nshare client:pull\n```\n\nIf the command is successful, you should end up with a `.vendia` directory that looks like this:\n\n```\n.vendia\n├── config.json\n├── schema.graphql\n└── schema.json\n```\nThis directory can be committed to your repository and shared with others working on the same project.\n\n## Step 2: Installing the client\n\nUse your favorite npm client to install the Vendia client package:\n\n```bash\nnpm install @vendia/client\n```\n\nThis _should_ be all you need to do.\n\nOnce the installation completes, a post-installation script will run automatically — this script generates custom TypeScript files (and compiles them to JavaScript and type declaration files). This is necessary for the client to work correctly!\n\nIf you installed the client _before_ pulling your Uni's schema, just follow [the steps above](#step-1-pulling-your-unis-schema) to pull with the CLI — you'll be prompted to run code generation afterwards.\n\nYou can also run _just_ code generation with the following command:\n```bash\nshare client:generate\n```\n\n#### **Help! I got an error during npm installation!**\n\nPlease take a look at [fixes for common issues](#fixes-for-common-issues) below!\n\n# Usage\n\n## Initializing the client\n\nYou can instantiate an instance of the Vendia client using the following code:\n\n```tsx\nimport { createVendiaClient } from '@vendia/client';\n\nconst client = createVendiaClient({\n  apiUrl: `<Your GraphQL URL>`,\n  websocketUrl: `<Your Websocket URL>`,\n});\n```\n\n**Options**\n\n- `apiUrl` - string, required\n- `websocketUrl` - string, optional (but required in order to use [GraphQL subscriptions](#realtime-data-graphql-subscriptions))\n- `apiKey` - string, optional (but required unless authorizing with [Vendia User credentials](#vendia-user))\n- `debug` - boolean, optional (set to `true` to enable verbose logging)\n\n## Authentication\n\nThe Vendia client currently supports two methods of authentication — **API key** and **Vendia User** credentials. More options coming soon!\n\n### API key\n\nThe easiest way to get started _in a server-side scenario_ is with your API key — it can be passed in via the `apiKey` option when instantiating the client:\n\n```tsx\nconst client = createVendiaClient({\n  apiUrl: `<Your GraphQL URL>`,\n  websocketUrl: `<Your Websocket URL>`,\n  apiKey: process.env.VENDIA_API_KEY // <---- API key\n});\n```\n\n_Warning — never expose your API key to untrusted users! API keys should only be used in server-side applications (node.js) and should always be accessed in code via environment variables._\n\n### Vendia User\n\nAuthenticate with the same username and password you use to login to [Vendia](http://share.vendia.net)!\n\n```tsx\nconst client = createVendiaClient({\n  apiUrl: `<Your GraphQL URL>`,\n  websocketUrl: `<Your Websocket URL>`,\n});\n\ntry {\n  await client.auth.loginWithVendiaUser('<Your Vendia Username>', '<Your Vendia Password>')\n} catch(e) {\n  // Handle login failures...\n}\n```\n\n## Reading and writing data\n\n### Working with Entities\n\nCRUD operations for each of the top-level data types (AKA “entities”) defined in your Vendia JSON schema are available under the `entities` namespace. Entity names are converted to camelCase when accessed here to conform with idiomatic JavaScript — \"CarParts\" will be available at `entities.carParts`, for example.\n\nAssuming your JSON schema had entities for “Product”, “Shipment”, and “User”, you could perform the following example operations:\n\n```tsx\nconst { entities } = client;\n\n// Create a new \"product\"\nconst productResponse = await entities.product.add({\n  name: 'super-widget',\n  inventory: 100\n})\n\n// List your \"shipments\"\nconst shipmentResponse = await entities.shipment.list() \n\n// Get a \"user\" by id\nconst userResponse = await entities.user.get('abc-123')\n```\n\n### Adding an item\n\nAdding new items can be performed with the `add` method. This method takes a single argument: an object containing the data to be added. The `add` method returns a promise that resolves to the newly created item.\n\n```tsx\nconst response = await entities.product.add({\n  name: 'super-widget',\n  inventory: 100\n})\n```\n\nSingular entities — that is, entities that are defined in your JSON schema as any type other than `\"array\"` — can be created with the `create` method rather than `add`.\n\n```tsx\nconst response = await entities.topSellingProductsSummary.create({\n  topSellingProductName: 'super-widget',\n  unitsSoldInLastNinetyDays: 100000,\n})\n```\n\n### Updating an item\n\nUpdating an item can be performed with the `update` method. This method has two required arguments: the `_id` of the item to be updated, and an object containing the data to be updated. The `update` method returns a promise that resolves to the updated item.\n\nA third, optional argument can be used to update an item [conditionally](#conditionally-updating-or-removing-items).\n\n```tsx\nconst response = await entities.product.update('abc-123', {\n  name: 'EVEN-MORE-SUPER-widget',\n  inventory: 1000000\n})\n```\n\n### Removing an item\n\nRemoving an item can be performed with the `remove` method. This method has a single required argument: the `_id` of the item to be removed. The `remove` method returns a promise that resolves to the removed item.\n\nA second, optional argument can be used to remove an item [conditionally](#conditionally-updating-or-removing-items).\n\n```tsx\nconst response = await entities.product.remove('abc-123')\n```\n\nSingular entities - that is, entities that are defined in your JSON schema as any type other than `\"array\"` - can be removed with the `delete` method rather than `remove`.\n\n```tsx\nconst response = await entities.topSellingProductsSummary.delete()\n```\n\n### Conditionally updating or removing items\n\nUpdate and removal mutations can be performed _conditionally_ - that is, the update/removal will only be performed if the item matches the provided conditions. Conditions are specified via an object passed to the `condition` option. Complex conditions can be specified by recursively nesting additional conditions via the `_and`/`_or` properties.\n```tsx\n\n  // Update only if the item has a name of \"super-widget\"\n  const updateResponse = await entities.product.update('abc-123', {\n    name: 'EVEN-MORE-SUPER-widget',\n    inventory: 1000000\n  }, {\n    condition: {\n      name: {\n        eq: 'super-widget'\n      }\n    }\n  })\n\n  // Remove only if the item has an inventory of 0 (or less) OR its name is prefixed with \"OBSOLETE\"\n  const removeResponse = await entities.product.remove('abc-123', {\n    condition: {\n      inventory: {\n        le: 0\n      },\n      _or: {\n        name: {\n          beginsWith: 'OBSOLETE'\n        }\n      }\n    }\n  })\n```\n\n### Listing items\n\nListing items can be performed with the `list` method. This method takes a single optional argument: an object containing options to be applied to the list request. The `list` method returns a promise that resolves to an array of items.\n\n```tsx\nconst response = await entities.product.list()\n```\n#### Pagination\n\nPagination is cursor-based — the `list` method will return a list of items along with a `nextToken` cursor that can be used to retrieve the next page of items - `nextToken` will be `null` when there are no more pages to retrieve.\n\n```tsx\nconst firstPage = await entities.product.list()\n\nconst secondPage = await entities.product.list({\n  nextToken: firstPage.nextToken\n})\n```\n\nThe number of items returned in each page can be controlled with the `limit` option (defaults to `50` items).\n\n#### Filtering\n\nList queries can be augmented with a powerful filtering syntax passed as an object to the `filter` option.\n\n```tsx\n// List all products where name contains 'widget', inventory is greater than 50, and price is less than 100\nconst response = await entities.product.list({\n  filter: {\n    name: {\n      contains: 'widget'\n    },\n    _and: {\n      inventory: {\n        gt: 50\n      },\n      _and: {\n        price: {\n          lt: 100\n        }\n      }\n    }\n  }\n})\n```\n\n### Retrieving an item\n\nRetrieving an item can be performed with the `get` method. This method has a single required argument: the `_id` of the item to be retrieved. The `get` method returns a promise that resolves to the retrieved item.\n```tsx\nconst response = await entities.product.get('abc-123')\n```\n#### Retrieving previous versions of an item\n\nPrevious versions can be retrieved by passing an optional second argument to the `get` method: an object containing the `version` of the item to be retrieved.\n```tsx\nconst response = await entities.product.get('abc-123', {\n  version: 1\n})\n```\n\n### Mutations are synchronous by default\n\nMutations will be performed _synchronously_, by default, meaning the promise returned from calling `add` won’t resolve until the data has been safely stored in your Uni — this is probably the behavior you would expect! Keep in mind, however, that Vendia is a decentralized, ledgered database and consensus amongst all participating nodes in your Uni is required before the data can be immutably ledgered. The consensus process can occasionally add a delay of _up to several seconds_ to mutation requests.\n\nIf you don't want or need to wait for this process to complete, you can use the `syncMode` option with a value of `ASYNC` — this will cause the mutation to be performed asynchronously, and the promise returned from the method will resolve as soon as _your node_ has received the request. You'll be provided a `transactionId` that can be used to check the status of the mutation later along with the `_id` of the item you're adding/updating/removing.\n\n```tsx\nconst response = await entities.product.add({\n  name: 'super-widget',\n  inventory: 100\n}, {\n  syncMode: 'ASYNC'\n})\n\nconsole.log(response?.transaction?.transactionId)\nconsole.log(response?.transaction?._id)\n```\n\n## Working with ACLs\n\nVendia allows you to control read and write access to the data in your Uni via access control lists (ACLs). ACLs can be powerful, but are completely optional — [you can read more about ACLs here](https://www.vendia.net/docs/share/fine-grained-data-permissions).\n\n#### Adding ACLs to mutations\n\nACLs can be passed to `add`/`update` mutations via the `aclInput` option. Note that this option will only be available for entities that have [ACLs enabled in your Uni's schema](https://www.vendia.net/docs/share/fine-grained-data-permissions#schema-definition-requirement).\n```tsx\n  // Add an item with an ACL specifying that all nodes (aside from you) are restricted to read-only access\n  const response = await entities.product.add({\n    name: 'read-only-widget',\n    inventory: 100\n  }, {\n    aclInput: {\n      acl: [\n        {\n          principal: {\n            nodes: [ \"*\" ]\n          },\n          operations: [ \"READ\" ]\n        }\n      ]\n    }\n  });\n```\n\n#### The client handles aliasing ACL responses automatically\n\nTL;DR: the client will automatically take care of some complexity when working with ACLs. Feel free to read the detailed explanation below if you're curious!\n\n<details>\n<summary>Detailed explanation</summary>\n\nEnabling ACLs adds some complexity to the underlying graphQL queries required to retrieve data — the queries must be [graphQL unions](https://graphql.org/learn/schema/#union-types) containing the usual response shape along with a \"partial\" version (wherein each top-level property of the response becomes _optional_). This is needed because the data being requested _might_ include fields that the requesting party (you, in this context) does not have permission to read (due to ACLs added by another party sharing the same Uni). GraphQL, unfortunately, does not provide a simple way to express this notion (eg, I would like data with a `name` field of type `String!`, but _leave that out of the response_ if I don't have permission to read it.)\n\nFormatting the requested data as a graphQL union, in turn, necessitates the use of graphQL field aliases for one side of the union to prevent type errors (a required `name` field, for example, will have the type `String!`, but this same `name` field will have type `String` on the \"partial\" side of the graphQL union and will therefore need to aliased with something like `alias_name: name`).\n\n```graphql\nquery MyQuery {\n  list_Product {\n    _Product {\n      ... on Self_Product {\n        name # <--- graphQL type of String!\n        color # <-- graphQL type of String!\n      }\n      ... on Self_Product_Partial_ {\n        alias_name: name # <---- graphQL type of String, alias required!\n        alias_color: color # <-- graphQL type of String, alias required!\n      }\n    }\n  }\n}\n```\n\nFortunately, the client library will take care of both _adding_ field aliases to the underlying graphQL queries of `get` and `list` (and the `result` selector of synchronous `add` and `update`) operations and _stripping_ the aliases from responses automatically.\n</details>\n\n## Realtime Data (GraphQL Subscriptions)\n\nThe Vendia client makes it easy to use graphQL subscriptions to respond to data updates in realtime. Changes to `entities`, `blocks`, `files`, `settings`, and more can all be subscribed to using the following format:\n\n```tsx\nconst { entities } = client; \n\nentities.product.onAdd(data => {\n  alert(`A new product named ${data.result.name} been added!`);\n});\n\nentities.product.onUpdate(data => {\n  alert(`An existing product named ${data.result.name} has been updated!`);\n});\n\nentities.product.onRemove(data => {\n  alert(`An existing product named ${data.result.name} has been removed!`);\n});\n```\n\nNon-entity types such as `blocks` and `files` follow the same format:\n\n```tsx\nconst { blocks, files } = client;\n\nblocks.onAdd(data => {\n  alert(`Block ${data.result.blockId} has been minted!`);\n});\n\nfiles.onUpdate(data => {\n  alert(`${data.result.destinationKey} has changed!`);\n});\n```\n\nSubscriptions return an unsubscribe method which can be used to terminate the subscription:\n\n```tsx\nconst unsubscribe = entities.product.onAdd(data => console.log(data));\n\n// No longer interested!\nunsubscribe()\n```\n\n## Storage\n\nFile/folder operations are accessed via the `files` and `folders` namespaces located under the `storage` namespace.\n[Learn more about Vendia file storage.](https://www.vendia.net/docs/share/file-storage)\n\nThe client currently supports copying files from existing S3 buckets and retrieving metadata about files on your Uni.\n\n_**Coming soon: support for directly uploading and retrieving files to your Uni from the client!**_\n\n```tsx\nconst { storage } = client;\nconst contractsFolder = 'contracts';\n\nconst addFolderResponse = await storage.folders.add({\n  name: contractsFolder,\n});\n\nconst addFileResponse = await storage.files.add({\n  destinationKey: `${contractsFolder}/my-contract.txt`,\n  sourceKey: \"my-contract.txt\",\n  sourceBucket: \"my-bucket\",\n  sourceRegion: \"us-east-1\"\n});\n\nconst getFileResponse = await storage.files.get(addFileResponse._id);\nconsole.log(`My contract is available at ${getFileResponse.destinationKey}!`);\n```\n\n## Blocks\n\nThe entire history of your Uni is available via the `blocks` namespace. Blocks can be accessed via `get` or `list` operations, and the `onAdd` subscription can be used to react to newly minted blocks in realtime. [Learn more about \"blocks\" and other Vendia terminology here](https://www.vendia.net/docs/share/terms-and-definitions#block).\n\n```tsx\nconst { blocks } = client;\n\nconst getResponse = await blocks.get(\"example-block-id-abc-123\");\nconst listResponse = await client.blocks.list()\n```\n\n## Settings\n\nVarious settings can be queried and updated using the `settings` namespace (e.g., auth, success/error notifications). Use the `get` and `update` operations to retrieve and update settings. The `onUpdate` subscription can be used to react to settings changes in realtime.\n```tsx\nconst response = await client.settings.get()\n```\n\n## Uni Info\n\nThe `uniInfo` namespace provides access to information about your Uni (e.g., its name, schema, and info about each participating node in the Uni). Use the `get` operation to retrieve the Uni info and the `onUpdate` subscription to react to changes in realtime.\n```tsx\nconst response = await client.uniInfo.get()\n```\n\n## Smart Contracts\n\nYou can use the `smartContracts` namespace to interact with your Uni's smart contracts. Use the `add`, `get`, `list`, `update`, and `remove` operations to perform CRUD operations on smart contracts.\n\n```tsx\nconst { contracts } = client;\n\nconst response = await contracts.add({\n  name: \"update-delivery-status\",\n  resource: { uri: \"arn:aws:lambda:us-west-2:123456789012:function:ContractEnforcement:9\" }, \n  description: \"a smart contract that updates the delivery status of a shipment\",\n  inputQuery: \"query shipmentDetails($id: ID!) { getShipment(id: $id) { _id orderId destinationWarehouse }}\",\n  outputMutation: \"mutation m($id: ID!, $delivered: Boolean, $lastUpdated: String, $orderId: String) { updateShipment(id: $id, input: { delivered: $delivered, lastUpdated: $lastUpdated, orderId: $orderId }, syncMode: ASYNC) { transaction { _id } } }\" \n})\n```\n\nSmart contracts can be invoked with the `invoke` method.\n\n```tsx\nconst response = await contracts.invoke('example-contract-id-abc-123')\n```\n\nYou can also use the `onAdd`, `onUpdate`, and `onRemove` subscriptions to react to changes in realtime. [Read all about Smart Contracts here](https://www.vendia.net/docs/share/smart-contracts).\n\n## Custom GraphQL requests\n\nIt is possible to make custom graphQL requests via the `request` method — this shouldn't be necessary often, but there are a few scenarios that the client does not directly support where custom requests might prove useful:\n1. For requesting a subset of fields — the client always requests _every_ field of a given data type which may be more data than you need.\n2. For executing batched queries or mutations (AKA performing more than one query or mutation in a single request).\n3. For executing [Vendia Transactions](https://www.vendia.net/docs/share/vendia-transaction), which require batching mutations in a single request, and additionally guarantee that mutations will be performed _serially, in order, as an atomic unit_.\n\n#### Requesting a subset of fields\n\n```tsx\n// Requesting a subset of fields on the Vendia Block type\nconst listBlocksQuery = `\n  query listBlocks {\n    listVendia_BlockItems {\n      Vendia_BlockItems {\n        blockId\n      }\n      nextToken\n    }\n  }\n`;\nconst response = await client.request(listBlocksQuery);\n\n// Returns the full graphQL \"data\" response\nconsole.log(response?.listVendia_BlockItems?.Vendia_BlockItems?.[0]?.blockId);\n```\n\n#### Executing a Vendia Transaction\n\n```tsx\nconst vendiaTransactionQuery = `\nmutation exampleMutation @vendia_transaction { # <-- vendia_transaction directive\n  update_Product(\n    id: \"abc-123\"\n    input: { inventory: 99 }\n    syncMode: NODE_LEDGERED\n  ) {\n    result {\n      inventory\n    }\n  }\n  update_User(\n    id: \"def-456\"\n    input: { products_purchased : 2 }\n    syncMode: NODE_LEDGERED\n  ) {\n    result {\n      products_purchased\n    }\n    transaction {\n      transactionId\n    }\n  }\n}\n`\nconst response = await client.request(vendiaTransactionQuery);\nconsole.log(response?.update_User?.transaction?.transactionId);\n```\n\n# Fixes for common issues\n\n**Issue: Received  ` Error: Cannot find module '../../.vendia-client/index'` when trying to build or run my code.**\n\nThis error means that code generation did not complete successfully. The most likely cause is that the `.vendia` folder is missing from the root of your project. Please follow the instruction above for [pulling your Uni's schema](#step-1-pulling-your-unis-schema).\n\n**Issue: I received an error during _installation_ or _code generation_.**\n\nPotential causes include the following:\n1. The `.vendia` folder is missing from the root of your project.\n2. You've updated **@vendia/client** to a new version which takes advantage of changes/additions to the core Vendia platform — you may need to pull the latest version of your Uni's schema (in this case, it's the generated GraphQL schema rather than your JSON schema that may be out of date). _This should only happen when bumping major versions of the client, but we're still in alpha at the moment and moving very quickly!_\n\nIn either case, please follow the instruction above for [pulling the latest version of your Uni's schema](#step-1-pulling-your-unis-schema) and follow the CLI prompts to execute code generation afterwards.\n\n**Issue: `client.entities` is an empty object! It doesn't contain any of the entities described by my Uni's JSON schema.**\n\nAgain, the most likely cause is that the `.vendia` folder is missing from the root of your project.\n\nIf the post-installation script can not locate the `.vendia` folder, it will fall back to using a generic Vendia schema that doesn't contain any of the entities described by your Uni's JSON schema — this results in an empty `client.entities` namespace (though all other aspects of client functionality should work). Please follow the instruction above for [pulling your Uni's schema](#step-1-pulling-your-unis-schema).\n\n**Issue: code completion (intellisense) doesn't work in WebStorm IDE (JavaScript projects only - should always work in TypeScript projects).**\n\nWorkaround: Open `preferences` → `languages and frameworks` → `javascript` → `libraries` → `add` → `+ button` →\nuse `command + shift + .` to show hidden folders (on Mac, not sure about Windows - apologies),\nselect `.vendia-client` directory. This adds all the types to the project.\n\n# Appendix\n\n## Schema evolution\n\nVendia allows you to evolve your schema as your data sharing requirements change — you can read more about schema evolution [here](https://www.vendia.net/blog/schema-evolution). Whenever you evolve your schema, you'll need to update the  schema files stored in your `.vendia` directory and generate new client code.\n\nUse the Vendia CLI to run the `share client:pull` command. This will pull the latest schema files to your `.vendia` directory and then issue the following prompt:\n```bash\nWould you like to update the auto-generated client code based on the latest schema?\nThis is highly recommended. (Y/n)\n```\nTap `Enter` to continue and you're done!\n\n## Code generation details\n\nThe `@vendia/client` package consists of a lightweight wrapper (the exported `createVendiaClient` function) along with a suite of tools used to dynamically generate TypeScript files based on your schema. When the package is installed/updated via npm/yarn/pnpm, a post-installation script will attempt to perform the following steps:\n\n1. Find the `.vendia` directory in the root of your project and read the schema/config files inside.\n2. Use the schema/config data to generate TypeScript code tailored to your Uni's schema.\n3. Create a `.vendia-client` directory inside `node_modules`\n4. Copy the wrapper TypeScript source code (`createVendiaClient`) and into `node_modules/.vendia-client`.\n5. Write the generated TypeScript code to `node_modules/.vendia-client/generated.ts`.\n6. Compile the TypeScript code to JavaScript and type declaration (*.d.ts) files.\n\nIf there is no `.vendia` directory, a generic Vendia schema that doesn't contain any \"entities\" (the data types defined by your Uni's JSON schema) will be used, resulting in an empty `client.entities` namespace (though all other aspects of client functionality should work).\n\nThis project was heavily inspired by [Prisma's awesome type-safe client](https://www.prisma.io/client) and made possible by a suite of amazing open-source tools; especially the incredible [GraphQL Code Generator](https://www.graphql-code-generator.com/)!\n\n#### FAQs\n\n**Why is the `.vendia-client` directory created in `node_modules`?**\n\nThere are a few reasons for this:\n1. This allows for a simpler installation process with very little configuration.\n2. It allows the client to be imported from a consistent location (e.g., `import { createVendiaClient } from '@vendia/client'`).\n3. We would prefer not to surprise anyone by modifying files outside of `node_modules` during a package installation.\n\n**Can I specify an alternate path for the generated files?**\n\nNot at this time. Please let us know if you need this! \n"
}