import { GraphQLClient, ClientError, RequestDocument, Variables } from 'graphql-request'
import { ClientOptions, Logger } from './types'
import { createAuth } from './create-auth'

export const createCoreClient = (
  options: ClientOptions,
  {
    _logger,
    _onAuthStateChange,
  }: { _logger: Logger; _onAuthStateChange?: ReturnType<typeof createAuth>['_onAuthStateChange'] },
) => {
  const { apiKey, getCredentials, onError } = options

  if (onError && typeof onError !== 'function') {
    throw new Error('onError must be a function')
  }
  const _errorHandler = onError

  _logger('Initializing @vendia/client...')
  _logger(`'apiKey' was ${apiKey ? '' : 'NOT '}provided.`)

  const _createGraphQLClient = () => {
    const opts: any = {
      headers: {
        'Content-Type': 'application/json',
      },
    }
    if (options.apiKey) {
      // Auth V1 uses x-api-key header, V2 uses Authorization header
      opts.headers['x-api-key'] = options.apiKey
      opts.headers['Authorization'] = options.apiKey
    }
    if (options.fetch) {
      opts.fetch = options.fetch
    }
    return new GraphQLClient(options.apiUrl, opts)
  }

  type SdkFunctionWrapper = <T>(
    action: (requestHeaders?: Record<string, string>) => Promise<T>,
    operationName: string,
  ) => Promise<T>

  const _requestWrapper: SdkFunctionWrapper = async (action, operationName: string) => {
    try {
      // Debug timer
      const startTime = Date.now()

      // Get credentials before each request (most auth libs handle caching or user can cache themselves)
      const requestHeaders: Record<string, string> = {}
      if (typeof getCredentials === 'function') {
        const credentials = await getCredentials()
        if (credentials?.token) {
          requestHeaders['Authorization'] = `Bearer ${credentials.token}`
        }
        if (credentials.apiKey) {
          requestHeaders['x-api-key'] = credentials.apiKey
          requestHeaders['Authorization'] = credentials.apiKey
        }
        _logger(`${operationName} getCredentials duration (ms)`, Date.now() - startTime)
      }

      const result = await action(requestHeaders)
      _logger(`${operationName} request duration (ms)`, Date.now() - startTime)
      return result
    } catch (error) {
      if (_errorHandler) {
        _logger(`Passing error to user-provided error handler`)
        _errorHandler(error as ClientError | Error)
      }
      return Promise.reject(error)
    }
  }

  const _gqlClient = _createGraphQLClient()
  // Copy the type signature of the GraphQLClient.request method and wrap it so it works
  // with getCredentials, errorHandler, etc.
  const request = <T = any, V = Variables>(
    document: RequestDocument,
    variables?: V | undefined,
    requestHeaders?: HeadersInit | undefined,
  ): Promise<T> => {
    return _requestWrapper((additionalHeaders) => {
      const mergedHeaders = { ...requestHeaders, ...additionalHeaders }
      return _gqlClient.request(document, variables, mergedHeaders)
    }, 'request')
  }

  return {
    // Internal
    _gqlClient,
    _requestWrapper,

    // Public
    request,
  }
}
